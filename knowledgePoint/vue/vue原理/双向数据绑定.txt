1.双向数据绑定

1.1是通过数据劫持结合发布者-订阅者模式实现的 通过Object.defineProperty()来劫持各个属性的setter和getter,在
数据变动的时候发布消息给订阅者，触发响应的监听回调；
注意：在你数据变化之后，Object.defineProperty中的set函数就知道了，所以就会触发双向数据绑定

1.2思路整理：
（1）实现一个数据监听器Observer,能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
（2）实现一个指令解析器Compile,对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
（3）实现一个watcher，作为链接Observer和Compile的桥梁，能够订阅并受到每个属性变动的通知，执行指令绑定的相应回调函数
从而能更新视图
（4）mvvm的入口函数，整合以上

1.3 Observer
利用Object.defineProperty中的get获取到之前的set设置新的，这样就可以监听每个数据的变化；
设置一个新的Dep放置订阅者，这个在get函数中将变换的数据放到Dep中，Dep的原型对象有个属性方法是数据变动触发notify,
再调用订阅者的update方法

1.4 Compile
解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定的更新函数，添加监听数据的
订阅者，一旦数据有变动，收到通知，更新视图

1.5 Watcher
watcher是链接Observer和Compile之间通信的桥梁
在自身实例化的时候忘属性订阅器 Dep里面添加自己
自身必须有一个update方法
待特性的dep.notice通知的时候，能调用update方法，并处罚Compile中绑定的回调，则功成身退

1.6 实现mvvm
mvvm作为数据绑定的入口，整合Observer Compile Watcher,通过Observe来监听自己的mobel数据变化，通过Compile来解析编译模板指令，
最终利用watcher搭起Observer和Compile之间额通信桥梁，达到数据变化

1.7 实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer,用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher
看是否需要更新。因为订阅者是有很多个的，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后监听器Observer和订阅者Watcher之间进行统一管理的。
接着，我们还需要有一个指令解析器Compile,对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher,并替换模板数据或者绑定相应的函数，
此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。














